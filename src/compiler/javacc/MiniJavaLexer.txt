// JavaCC Options.

options {
  JAVA_UNICODE_ESCAPE = true;
}

// Parser Class.

PARSER_BEGIN(MiniJavaParser)
  package compiler.javacc;
  public class MiniJavaParser {}
PARSER_END(MiniJavaParser)


// Lexical Analysis.

TOKEN: {
	  < CLASS: "class" >
	| < WHILE: "while" >
	| < PUBLIC: "public" >
	| < STATIC: "static" >    
	| < VOID: "void" >
	| < MAIN: "main" >   
	| < EXTENDS: "extends" >
	| < RETURN: "return" >
	
	| < OPNOT: "!" >
	| < OPAND: "&&" >
	| < OPLT: "<" >
	| < OPPLUS: "+" >
	| < OPMINUS: "-" >
	| < OPTIMES: "*" >
	
	| < NEW: "new" >
	| < THIS: "this" >
	| < LENGTH: "length" >
	
	| < STRING: "String" >
	| < INT: "int" > 
	| < BOOLEAN: "boolean" >
	
	| < TRUE: "true" >
	| < FALSE: "false" >
	
	| < IF : "if" >
	| < ELSE : "else" >
	
	| < #DIGIT: ["0"-"9"] >
	| < #CHARACTER: (["a"-"z"]) >
	| < ID: <CHARACTER>(<CHARACTER>|<DIGIT>)* >
	| < NUM: (<DIGIT>)+ >
	| < REAL: ( (<DIGIT>)+ "." (<DIGIT>)* ) | ((<DIGIT>)* "." (<DIGIT>)+ ) >
	| < INTEGER_LITERAL: (<NUM>) >
}

SKIP: {
	  < "--" (<CHARACTER>)* ("\n" | "\r" | "\r\n") >
	|" "
	|"\t"
	|"\n"
}

// The following is a simple grammar that will allow you
// to test the generated lexer.

// Grammar.

void Goal() :
{}
{
	MainClass()
	( ClassDeclaration() )*
	<EOF>
}

void MainClass() :
{}
{
	"class" Identifier() "{"
	"public" "static" "void" "main" "(" "String" "[" "]" Identifier() ")"
"{" Statement() "}"
"}"
}

void ClassDeclaration() :
{}
{
	"class" Identifier() ( "extends" Identifier() )? "{"
	( VarDeclaration() )* ( MethodDeclaration() )* "}"
}

void VarDeclaration():
{}
{
	Type() Identifier() ";"
}

void MethodDeclaration():
{}
{
	"public" Type() Identifier() "(" 
(Type() Identifier() ( "," Type() Identifier() )*)?
")" "{"
		( LOOKAHEAD(2) VarDeclaration() )* ( Statement() )* "return" Expression() ";"
"}"
}

void Type():
{}
{
	  LOOKAHEAD(2) "int" "[" "]"
	| "boolean"
	| "int"
	| Identifier()
}
void Statement():
{}
{
	  "{" ( Statement() )* "}"
	| "if" "(" Expression() ")" Statement() "else" Statement()
	| "while" "(" Expression() ")" Statement()
	| "System.out.println" "(" Expression() ")" ";"
	| LOOKAHEAD(2) Identifier() "=" Expression() ";"
	| Identifier() "[" Expression() "]" "=" Expression() ";"
}

void Identifier():
{}
{
	<ID>
}

void Expression():
{}
{
	  ExpressionPrim() (ExpressionTerm())*
	| "!" Expression()
}

void ExpressionPrim():
{}
{
	  "true"
	| "false"
	| <INTEGER_LITERAL>
	| Identifier()
	| "this"
	| LOOKAHEAD(2) "new" Identifier()
	| "new" "int" "[" Expression() "]"
	| "(" Expression() ")"
}

void ExpressionTerm():
{}
{
	  ( "&&" | "<" | "+" | "-" | "*" ) ExpressionPrim()
	| "[" Expression() "]"
	| LOOKAHEAD(2) "." "length"
	| "." Identifier() "(" (Expression() ("," Expression())*)? ")"
}