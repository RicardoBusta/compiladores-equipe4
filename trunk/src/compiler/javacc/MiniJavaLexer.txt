// JavaCC Options.

options {
  JAVA_UNICODE_ESCAPE = true;
}

// Parser Class.

PARSER_BEGIN(MiniJavaParser)
  package compiler.javacc;
  public class MiniJavaParser {}
PARSER_END(MiniJavaParser)


// Lexical Analysis.

TOKEN: {
	  < CLASS: "class" >
	| < WHILE: "while" >
	| < PUBLIC: "public" >
	| < STATIC: "static" >    
	| < VOID: "void" >
	| < MAIN: "main" >   
	| < EXTENDS: "extends" >
	| < RETURN: "return" >
	
	| < NEW: "new" >
	| < THIS: "this" >
	| < LENGTH: "length" >
	
	| < STRING: "String" >
	| < INT: "int" > 
	
	| < TRUE: "true" >
	| < FALSE: "false" >
	
	| < IF : "if" >
	| < ELSE : "else" >
	
	| < #DIGIT: ["0"-"9"] >
	| < #CHARACTER: (["a"-"z"]) >
	| < ID: <CHARACTER>(<CHARACTER>|<DIGIT>)* >
	| < NUM: (<DIGIT>)+ >
	| < REAL: ( (<DIGIT>)+ "." (<DIGIT>)* ) | ((<DIGIT>)* "." (<DIGIT>)+ ) >
	| < INTEGER_LITERAL: (<NUM>) >
}

SKIP: {
	  < "--" (<CHARACTER>)* ("\n" | "\r" | "\r\n") >
	|" "
	|"\t"
	|"\n"
}

// The following is a simple grammar that will allow you
// to test the generated lexer.

// Grammar.

void Goal() :
{}
{
	MainClass()
	( ClassDeclaration() )*
	<EOF>
}

void MainClass() :
{}
{
	"class" Identifier() "{"
	"public" "static" "void" "main" "(" "String" "[" "]" Identifier() ")"
	"{" Statement() "}"
	"}"
}

void ClassDeclaration() :
{}
{
	"class" Identifier() ( "extends" Identifier() )? "{"
	( VarDeclaration() )* ( MethodDeclaration() )* "}"
}

void VarDeclaration():
{}
{
	Type() Identifier() ";"
}

void MethodDeclaration():
{}
{
	"public" Type() Identifier() "(" Type() Identifier() ( "," Type() Identifier() )* ")" "{"
	( VarDeclaration() )* ( Statement() )* "return" Expression() ";" "}"
}

void Type():
{}
{
	  "int" /*"[" "]"
	| "boolean"
	| "int"
	| Identifier()*/
}

void Statement():
{}
{
	  "{" ( Statement() )* "}"
	| "if" "(" Expression() ")" Statement() "else" Statement()
	| "while" "(" Expression() ")" Statement()
	| "System.out.println" "(" Expression() ")" ";"
	| LOOKAHEAD(2) Identifier() "=" Expression() ";"
	| Identifier() "[" Expression() "]" "=" Expression() ";"
}

void ExpressionTerminal():
{}
{
	  "true"
	| "false"
	| "this"
	| Identifier()
	| "new" Identifier() "(" ")"
	| <INTEGER_LITERAL>
}

void Expression():
{}
{
	  LOOKAHEAD(1) Expression() ( "&&" | "<" | "+" | "-" | "*" ) Expression() 
	| LOOKAHEAD(1) Expression() "[" Expression() "]"
	| LOOKAHEAD(2) Expression() "." "length"
	| LOOKAHEAD(1) Expression() "." Identifier() "(" (Expression() ( "," Expression() )* )? ")"
	| LOOKAHEAD(1) "new" "int" "[" Expression() "]"
	| "!" Expression()
	| "(" Expression() ")"
	| ExpressionTerminal()
}

void Identifier():
{}
{
	<ID>
}